# Tracil Cursor Rules

## Constraints
- Do not persist uploaded files server-side; processing must be ephemeral.
- Never expose API keys in client code. In production, LLM calls go through server routes. During development with `AI_MODE=mock`, no external LLM calls occur.
- Prefer in-browser parsing; use serverless endpoints only when necessary and discard payloads immediately.

## Architecture and ownership
- UI flows live in `app/` (App Router). Shared UI in `components/`. Vertical slices in `features/`.
- Interactive workspace UI is implemented as a client component under `app/(workspace)/_components/` and rendered by `app/page.tsx`.
- Pure domain logic in `lib/` with an AI workspace at `lib/ai/` (entrypoints, parsers, lineage IR, provider). Keep these framework-agnostic.
- Client state in `state/` (Zustand) and reusable hooks in `hooks/`.
- Serverless API routes in `app/(api)/` are optional for later; when present, they are stateless proxies with strict timeouts that call `@ai/entrypoints/*`.
- Web developer focus: `app/`, `components/`, `features/`, `hooks/`, `styles/`.
- AI developer focus: `lib/ai/` (entrypoints, lineage, parsers, provider), `types/`, tests. API glue can be added later without changing entrypoint contracts.

## Coding standards
- TypeScript strict. Avoid `any`. Use explicit function signatures for exports and public APIs.
- Prefer descriptive names; avoid abbreviated identifiers.
- Keep functions small with early returns; handle edge cases first.
- No silent catches. Provide meaningful error messages.
- Keep code pure in `lib/`. Side effects only in routes, components, or dedicated hooks.

## UI/UX
- Use shadcn/ui components and Tailwind for layout. Provide dark mode.
- Ensure accessibility: keyboard navigation and proper ARIA roles.
- Keep pages responsive and performant (virtualized lists for large datasets).
- Use CSS variables (OKLCH) for theme tokens. In Tailwind v4, consume tokens via `bg-[var(--token)]` etc. Keep color logic centralized in `app/globals.css`.
- For the main screen, the left pane width is a fixed 260px on md+ (`md:grid-cols-[260px_1fr]`).

## LLM usage
- Implement a provider abstraction in `lib/ai/provider` with adapters for `gpt`, `claude`, and `gemini`. Select via `LLM_PROVIDER` env.
- Control runtime mode with `AI_MODE=mock|live|auto`. In `mock`, entrypoints return canned results; in `live`, they call providers; in `auto`, use live if keys are present.
- Redact PII/PHI and sample data values before sending to LLMs. Prefer metadata-only prompts.
- Chunk large inputs; enforce token budgets; stream responses where supported.
- UI must not call provider SDKs directly. UI imports only `@ai/entrypoints/*` now; later it may call server routes that delegate to entrypoints.

## Parsing and validation
- Support XPT (v5), SAS7BDAT, XLSX, DOCX, PDF, RTF.
- Use Web Workers for heavy parsing to avoid blocking the UI.
- Provide basic CDISC checks and return concise validation statuses (✔ / ❌ / 缺失).

## Testing and quality
- Lint, typecheck, and unit tests must pass on PRs. Keep edits small and focused.
- Unit tests for parsers, lineage builders, and LLM normalization.
- E2E smoke: upload → select → variables → lineage.

## Git and CI
- Conventional commits. Update `docs/` when schema or flows change.
- Keep environment variables in `.env.local` (not committed). Document in `.env.example`.

## Performance and privacy
- Avoid large in-memory retention of files; clear buffers after use.
- No server-side persistence. Respect Vercel limits and timeouts.
- Serverless is lower priority initially; design entrypoints so server routes can be added later without changing UI contracts.

## 2025 Development Checklist (All Required)

**Before Every Commit:**
- [ ] TypeScript strict compilation passes (zero errors)
- [ ] ESLint accessibility rules pass (zero violations)
- [ ] Automated accessibility tests pass
- [ ] Performance budgets met
- [ ] All interactive elements keyboard accessible
- [ ] Proper ARIA labels and roles
- [ ] Error boundaries implemented where needed
- [ ] Documentation updated

**Component Development:**
- [ ] Use named imports: `import { useState } from 'react'`
- [ ] ReactNode return type
- [ ] Proper memoization (memo, useMemo, useCallback)
- [ ] Error boundary coverage
- [ ] Accessibility testing
- [ ] Keyboard navigation support
- [ ] Screen reader compatibility
- [ ] Performance optimization

**Quality Standards:**
- WCAG 2.2 AA compliance (non-negotiable)
- Core Web Vitals in "Good" range
- 90%+ test coverage for critical components
- Zero TypeScript errors or ESLint violations
- Comprehensive accessibility testing
- Performance monitoring integration
